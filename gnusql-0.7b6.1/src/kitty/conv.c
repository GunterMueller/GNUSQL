/*
 *  conv.c -  collection routines used by functions, generated by kitty.
 *            It's part of GNU SQL compiler
 *
 * This file is a part of GNU SQL Server
 *
 *  Copyright (c) 1996-1998, Free Software Foundation, Inc
 *  Developed at the Institute of System Software
 *  This file is written by Andrew Yahin.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *  Contacts: gss@ispras.ru
 *
 */

/* $Id: conv.c,v 1.246 1998/09/29 21:26:15 kimelman Exp $ */

#include "global.h"
#include <stdarg.h>
#include "kitty.h"
#include "cycler.h"
#include <assert.h>


void 
arity_trn(TXTREF oper)
{
  TXTREF t;
  i4_t i=0;
  if(HAS_DOWN(oper))
    {
      for(i=0,t=DOWN_TRN(oper);t;t=RIGHT_TRN(t))
	i++;
      ARITY_TRN(oper)=i;   
    }
}

TXTREF
rl_corrector(i4_t line,TXTREF node,TXTREF right_link)
{
  if(node)
    {
      register TXTREF n=node;
      if(line)
	while(RIGHT_TRN(n))
	  n=RIGHT_TRN(n);
      RIGHT_TRN(n)=right_link;
      return node;
    }
  return right_link;
}

TXTREF 
dl_corrector(i4_t line,TXTREF node,TXTREF addit_down_link)
{
  register TXTREF n=DOWN_TRN(node);
  if(n && line)
    {
      while(RIGHT_TRN(n))
	n=RIGHT_TRN(n);
      RIGHT_TRN(n)=addit_down_link;
    }
  else
    DOWN_TRN(node)=addit_down_link;
  arity_trn(node);
  return node;
}

TXTREF
del_op( TXTREF operand,TXTREF parent)
{
  register TXTREF t;
  if(!operand) return parent;
  t=DOWN_TRN(parent);
  if(t==operand)
    DOWN_TRN(parent)=RIGHT_TRN(operand);
  else 
    { 
      while(t && RIGHT_TRN(t)!=operand)
	t=RIGHT_TRN(t);
      if(!t)
	return parent;
      RIGHT_TRN(t)=RIGHT_TRN(operand); 
    }
  ARITY_TRN(parent)--;
  RIGHT_TRN(operand)=TNULL;
  return parent;
}

TXTREF
replace_node(TXTREF by,TXTREF what,TXTREF parent)
{
  TXTREF t = DOWN_TRN(parent);
  if(!by)return parent;
  if(what==t)
    {
      DOWN_TRN(parent)  = by;
      RIGHT_TRN(by) = RIGHT_TRN(what);
    }
  else
    {
      while(t && RIGHT_TRN(t) != what)
	t=RIGHT_TRN(t);
      if(t)
	{
	  RIGHT_TRN(t)  = by;
	  RIGHT_TRN(by) = RIGHT_TRN(what); 
	}
    }
  return parent;
}

/* 
 * looking for image of node 'p' in tree 'dest'. This tree is the exact
 * copy of tree 'src' where node 'p' is
 */

TXTREF
image (TXTREF p,TXTREF dest,TXTREF src)
{
  
  assert(trn_equal_p(src,dest));
  if (src == TNULL)
    return TNULL;
  if(HAS_DOWN(src))
    {
      register TXTREF res = image (p,DOWN_TRN(dest),DOWN_TRN(src));
      if (res) 
	return res;
    }
  return image (p, RIGHT_TRN(dest), RIGHT_TRN(src));
}

TXTREF
insert_node(i4_t before,TXTREF in,TXTREF what,TXTREF where)
{
  TXTREF t=DOWN_TRN(in);
#define after (!before)
  
  if ( after && where )
    {
      RIGHT_TRN(what)=RIGHT_TRN(where);
      RIGHT_TRN(where)=what;
    }
  else if (before && (t==where || where==TNULL))
    {
      RIGHT_TRN(what) = t;
      DOWN_TRN(in)    = what;
    }
  else
    {
      while(t && RIGHT_TRN(t)!=where)
	t=RIGHT_TRN(t);
      /* we assume now that t.right_ptr --> 'where' or '0' */
      assert(t); 
      if (before || where==TNULL)
	{
	  RIGHT_TRN(what)=where;
	  RIGHT_TRN(t)=what;
	}
      else /* where && after */
	{
	  RIGHT_TRN(what)=RIGHT_TRN(where);
	  RIGHT_TRN(where)=what;
	}
    }
#undef after 
  ARITY_TRN(in)++;
  return in;
}
