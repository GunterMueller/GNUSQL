
/*  A Bison parser, made from parse.y with Bison version GNU Bison version 1.24
  */

#define YYBISON 1  /* Identify Bison output.  */

#define YYLSP_NEEDED

#define	TOK_ALL	258
#define	TOK_ALTER	259
#define	TOK_ANY	260
#define	TOK_AS	261
#define	TOK_ASC	262
#define	TOK_AUTHORIZATION	263
#define	TOK_BEGIN	264
#define	TOK_BETWEEN	265
#define	TOK_BY	266
#define	TOK_CHECK	267
#define	TOK_CLOSE	268
#define	TOK_COBOL_LANG	269
#define	TOK_C_LANG	270
#define	TOK_COMMIT	271
#define	TOK_CONTINUE	272
#define	TOK_CREATE	273
#define	TOK_CURRENT	274
#define	TOK_CURSOR	275
#define	TOK_DECLARE	276
#define	TOK_DEFAULT	277
#define	TOK_DELETE	278
#define	TOK_DESC	279
#define	TOK_DISTINCT	280
#define	TOK_DROP	281
#define	TOK_END	282
#define	TOK_ESCAPE	283
#define	TOK_EXISTS	284
#define	TOK_FETCH	285
#define	TOK_FOR	286
#define	TOK_FOREIGN	287
#define	TOK_FORTRAN_LANG	288
#define	TOK_FOUND	289
#define	TOK_FROM	290
#define	TOK_GOTO	291
#define	TOK_GRANT	292
#define	TOK_GROUP	293
#define	TOK_HAVING	294
#define	TOK_IN	295
#define	TOK_INDICATOR	296
#define	TOK_INSERT	297
#define	TOK_INTO	298
#define	TOK_IS	299
#define	TOK_KEY	300
#define	TOK_LANGUAGE	301
#define	TOK_LIKE	302
#define	TOK_MODULE	303
#define	TOK_NULL	304
#define	TOK_OF	305
#define	TOK_ON	306
#define	TOK_OPEN	307
#define	TOK_OPTION	308
#define	TOK_ORDER	309
#define	TOK_PASCAL_LANG	310
#define	TOK_PL1_LANG	311
#define	TOK_PRIMARY	312
#define	TOK_INDEX	313
#define	TOK_PRIVILEGES	314
#define	TOK_PROCEDURE	315
#define	TOK_PUBLIC	316
#define	TOK_REFERENCES	317
#define	TOK_REVOKE	318
#define	TOK_ROLLBACK	319
#define	TOK_SCHEMA	320
#define	TOK_SECTION	321
#define	TOK_SELECT	322
#define	TOK_SET	323
#define	TOK_SOME	324
#define	TOK_SQLCODE	325
#define	TOK_SQLERROR	326
#define	TOK_TABLE	327
#define	TOK_TO	328
#define	TOK_UNION	329
#define	TOK_UNIQUE	330
#define	TOK_UPDATE	331
#define	TOK_USER	332
#define	TOK_VALUES	333
#define	TOK_VIEW	334
#define	TOK_WHENEVER	335
#define	TOK_WHERE	336
#define	TOK_WITH	337
#define	TOK_WORK	338
#define	TOK_AND	339
#define	TOK_OR	340
#define	TOK_NOT	341
#define	TOK_NE	342
#define	TOK_GE	343
#define	TOK_LE	344
#define	TOK_AVG	345
#define	TOK_MAX	346
#define	TOK_MIN	347
#define	TOK_SUM	348
#define	TOK_COUNT	349
#define	TOK_IDENTIFIER	350
#define	TOK_PARAM	351
#define	TOK_INTEGER_CONST	352
#define	TOK_NUM_CONST	353
#define	TOK_REAL_CONST	354
#define	TOK_STRING_CONST	355
#define	TOK_T_CHAR	356
#define	TOK_T_NUM	357
#define	TOK_T_INT	358
#define	TOK_T_SINT	359
#define	TOK_T_FLT	360
#define	TOK_T_DOUBLE	361
#define	TOK_T_PRECISION	362
#define	TOK_T_REAL	363
#define	UNARY	364
#define	BRACETS	365



/* 
 *  parse.y   -   SQL grammar (ANSI SQL'89 + some extention) 
 *                of GNU SQL compiler
 *
 *  This file is a part of GNU SQL Server
 *
 *  Copyright (c) 1996, 1997, Free Software Foundation, Inc
 *  Developed at the Institute of System Programming
 *  This file is written by Michael Kimelman.
 * 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *  Contact:  gss@ispras.ru
 *
 */

/* $Id: parse.y,v 1.247 1998/09/28 05:00:06 kimelman Exp $ */

#include "trl.h"
#include "tree_gen.h"
#include "cycler.h"
#include "sql_decl.h"
#include "xmem.h"
#include "type_lib.h"
#include "svr_lib.h"
#include <assert.h>
#include "tassert.h"

char *dyn_sql_stmt_name  = NULL;
i4_t   dyn_sql_section_id = 0;

static TN      tblnm;
static i4_t     del_local_vcb    = 0;
static char   *label_nf         = NULL;
static char   *label_er         = NULL;
static i4_t     subquery         = 0;
static TXTREF  new_table        = TNULL;
static i4_t     new_table_col_no = 0;
static call_t  call;

static enum 
{
  Esql,
  Module,
  Schema,
  Dynamic
} parse_mode=Esql;

#ifdef stderr
#  undef stderr
#endif
#ifdef stdout
#  undef stdout
#endif

#define stderr STDERR
#define stdout STDOUT

#define FICTIVE_NODE  (TXTREF)(-1L)

#define FREE_VCB   free_line(LOCAL_VCB_ROOT)
#define YYERROR_VERBOSE
#define YYERROK { new_table = TNULL; yyerrok; }
i4_t yylex (void);

static void   check_not_null __P((TXTREF ind));
static void   free_tail __P((void));
static TXTREF replace_column_holes __P((TXTREF rb,VCBREF tbl));
static void   add_table_column(enum token tbl_code, LTRLREF ltrp,
                               sql_type_t type, TXTREF def,TXTREF constr);
static void   emit_module_proc __P((VCBREF parmlist,LTRLREF procname));
static void   emit_call __P((TXTREF vcb,i4_t object_id, i4_t method_id));

#define add_base_column(ltrp,type,def,constr) \
     add_table_column(TABLE,ltrp,type,def,constr)
#define add_view_column(ltrp,type) \
     add_table_column(VIEW,ltrp,type,TNULL,TNULL)



typedef union {
  LTRLREF  ltrp;
  TXTREF   node;
  i4_t      code;
  sql_type_t     type;
  void     *ptr;
} YYSTYPE;

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		482
#define	YYFLAG		-32768
#define	YYNTBASE	123

#define YYTRANSLATE(x) ((unsigned)(x) <= 365 ? yytranslate[x] : 240)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,   117,
   118,   114,   112,   111,   113,   116,   115,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,   119,   121,
   120,   122,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109,   110
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     4,     6,     8,    10,    12,    14,    16,    18,
    20,    22,    24,    28,    32,    34,    36,    38,    40,    42,
    45,    51,    53,    57,    59,    61,    66,    67,    70,    72,
    74,    76,    77,    79,    81,    84,    87,    91,    93,    96,
    98,   103,   110,   113,   115,   118,   120,   124,   125,   129,
   131,   135,   138,   145,   146,   150,   152,   154,   162,   163,
   167,   170,   172,   174,   178,   180,   182,   184,   187,   190,
   192,   194,   196,   200,   202,   204,   206,   210,   214,   218,
   221,   223,   225,   228,   232,   235,   238,   240,   243,   246,
   253,   260,   266,   272,   279,   283,   286,   287,   291,   293,
   297,   300,   302,   304,   305,   307,   309,   311,   315,   318,
   320,   322,   324,   326,   328,   330,   332,   334,   336,   338,
   340,   343,   346,   351,   354,   359,   364,   370,   375,   377,
   379,   383,   385,   388,   391,   398,   400,   402,   408,   414,
   416,   420,   424,   426,   428,   430,   432,   437,   439,   443,
   447,   452,   454,   456,   458,   462,   467,   470,   472,   476,
   479,   481,   482,   484,   487,   492,   494,   495,   499,   500,
   503,   505,   509,   513,   517,   520,   523,   526,   530,   533,
   538,   545,   551,   556,   560,   562,   564,   567,   569,   571,
   573,   575,   577,   579,   581,   583,   585,   586,   588,   589,
   592,   594,   598,   602,   604,   608,   615,   620,   622,   624,
   625,   627,   629,   633,   637,   641,   645,   649,   652,   654,
   656,   658,   660,   662,   664,   666,   668,   671,   673,   678,
   684,   690,   696,   698,   700,   702,   704,   706,   708,   710,
   712,   714,   716,   718,   720,   722,   725,   730,   732,   737,
   739,   744,   751,   753,   755,   757,   759,   763,   765,   769,
   771,   775,   781,   783,   787,   789,   791,   793,   797,   800,
   804,   807,   809,   813,   819,   821,   825,   828,   832
};

static const short yyrhs[] = {   126,
     0,   127,     0,   162,     0,   166,     0,   167,     0,   157,
     0,   175,     0,   125,     0,     1,     0,    72,     0,    79,
     0,   194,     0,    26,   124,   231,     0,   128,    65,   165,
     0,   129,     0,   145,     0,   149,     0,    18,     0,     4,
     0,   128,   130,     0,    72,   230,   117,   131,   118,     0,
   132,     0,   131,   111,   132,     0,   133,     0,   139,     0,
    95,   229,   134,   136,     0,     0,    22,   135,     0,    77,
     0,    49,     0,   228,     0,     0,   137,     0,   138,     0,
   137,   138,     0,    86,    49,     0,    86,    49,   141,     0,
   142,     0,    12,   210,     0,   140,     0,   141,   117,   144,
   118,     0,    32,    45,   117,   144,   118,   142,     0,    12,
   210,     0,    75,     0,    57,    45,     0,    58,     0,    62,
   231,   143,     0,     0,   117,   144,   118,     0,    95,     0,
   144,   111,    95,     0,    18,   146,     0,    79,   230,   143,
     6,   196,   147,     0,     0,    82,    12,    53,     0,    37,
     0,    63,     0,   148,   151,    51,   231,    73,   154,   150,
     0,     0,    82,    37,    53,     0,     3,    59,     0,   152,
     0,   153,     0,   152,   111,   153,     0,    67,     0,    42,
     0,    23,     0,    76,   143,     0,    62,   143,     0,   155,
     0,    61,     0,   156,     0,   155,   111,   156,     0,    95,
     0,   158,     0,   159,     0,     9,    21,    66,     0,    27,
    21,    66,     0,    80,   160,   161,     0,    86,    34,     0,
    71,     0,    17,     0,    36,    95,     0,   163,   164,   165,
     0,   163,     1,     0,    48,    95,     0,    48,     0,    46,
    95,     0,     8,    95,     0,    21,    95,    20,    31,   194,
   168,     0,    60,    95,   173,   119,   175,   119,     0,    60,
    95,   119,   175,   119,     0,    60,    95,   119,     1,   119,
     0,    60,    95,   173,   119,     1,   119,     0,    60,     1,
   119,     0,     1,   119,     0,     0,    54,    11,   169,     0,
   170,     0,   169,   111,   170,     0,   171,   172,     0,    97,
     0,   235,     0,     0,     7,     0,    24,     0,   174,     0,
   173,   111,   174,     0,    95,   229,     0,    70,     0,   176,
     0,   177,     0,   178,     0,   179,     0,   180,     0,   181,
     0,   185,     0,   186,     0,   187,     0,   189,     0,    13,
   207,     0,    16,    83,     0,    23,    35,   232,   204,     0,
    23,   206,     0,    23,    35,   232,   206,     0,    30,   207,
    43,   236,     0,    42,    43,   232,   143,   182,     0,    78,
   117,   183,   118,     0,   196,     0,   184,     0,   183,   111,
   184,     0,   193,     0,    52,   207,     0,    64,    83,     0,
    67,   188,   198,    43,   236,   200,     0,   221,     0,    25,
     0,    76,   232,    68,   190,   204,     0,    76,   232,    68,
   190,   206,     0,   191,     0,   190,   111,   191,     0,    95,
   120,   192,     0,   193,     0,   222,     0,    49,     0,   195,
     0,   194,    74,   221,   195,     0,   196,     0,   117,   194,
   118,     0,   117,   197,   118,     0,    67,   188,   198,   200,
     0,   199,     0,   114,     0,   222,     0,   199,   111,   222,
     0,   201,   204,   208,   209,     0,    35,   202,     0,   203,
     0,   202,   111,   203,     0,   231,    95,     0,   231,     0,
     0,   205,     0,    81,   210,     0,    81,    19,    50,   207,
     0,    95,     0,     0,    38,    11,   234,     0,     0,    39,
   210,     0,   211,     0,   117,   210,   118,     0,   210,    85,
   210,     0,   210,    84,   210,     0,    86,   210,     0,     1,
    85,     0,     1,    84,     0,   117,     1,   118,     0,    29,
   219,     0,   235,    44,   215,    49,     0,   222,   215,    10,
   222,    84,   222,     0,   222,   215,    47,   225,   216,     0,
   222,   215,    40,   217,     0,   222,   213,   212,     0,   222,
     0,   219,     0,   214,   219,     0,   120,     0,    87,     0,
   121,     0,   122,     0,    89,     0,    88,     0,     3,     0,
     5,     0,    69,     0,     0,    86,     0,     0,    28,   225,
     0,   219,     0,   117,   218,   118,     0,   117,     1,   118,
     0,   225,     0,   218,   111,   225,     0,   117,    67,   188,
   220,   200,   118,     0,   117,    67,     1,   118,     0,   222,
     0,   114,     0,     0,     3,     0,   224,     0,   117,   222,
   118,     0,   222,   112,   222,     0,   222,   113,   222,     0,
   222,   114,   222,     0,   222,   115,   222,     0,   223,   222,
     0,   112,     0,   113,     0,   239,     0,   228,     0,   226,
     0,    77,     0,   238,     0,   228,     0,   223,   228,     0,
    77,     0,    94,   117,   114,   118,     0,    94,   117,    25,
   235,   118,     0,   227,   117,    25,   235,   118,     0,   227,
   117,   221,   222,   118,     0,    90,     0,    91,     0,    92,
     0,    93,     0,    97,     0,    99,     0,    98,     0,   100,
     0,   101,     0,   104,     0,   103,     0,   108,     0,   106,
     0,   106,   107,     0,   105,   117,    97,   118,     0,   105,
     0,   101,   117,    97,   118,     0,   102,     0,   102,   117,
    97,   118,     0,   102,   117,    97,   111,    97,   118,     0,
   233,     0,   233,     0,   231,     0,    95,     0,    95,   116,
    95,     0,   235,     0,   234,   111,   235,     0,    95,     0,
    95,   116,    95,     0,    95,   116,    95,   116,    95,     0,
   237,     0,   236,   111,   237,     0,   238,     0,    95,     0,
    96,     0,    95,    41,    95,     0,    95,    95,     0,    96,
    41,    96,     0,    96,    96,     0,    95,     0,    95,   116,
    95,     0,    95,   116,    95,   116,    95,     0,    96,     0,
    95,    41,    95,     0,    95,    95,     0,    96,    41,    96,
     0,    96,    96,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   244,   253,   260,   262,   264,   269,   271,   279,   280,   294,
   295,   299,   316,   330,   339,   340,   341,   345,   347,   352,
   362,   382,   384,   389,   390,   394,   403,   404,   409,   414,
   416,   421,   423,   428,   430,   435,   437,   439,   441,   448,
   475,   481,   491,   501,   502,   503,   507,   518,   519,   524,
   528,   535,   546,   601,   602,   606,   608,   613,   649,   650,
   654,   655,   659,   660,   664,   666,   668,   670,   672,   677,
   678,   687,   688,   692,   705,   706,   710,   711,   715,   723,
   724,   728,   729,   738,   740,   749,   751,   756,   770,   790,
   820,   826,   831,   836,   841,   846,   854,   855,   860,   861,
   865,   873,   879,   888,   889,   890,   895,   896,   900,   918,
   945,   972,   973,   974,   975,   976,   977,   978,   979,   980,
   984,   998,  1008,  1015,  1036,  1060,  1084,  1101,  1103,  1108,
  1109,  1113,  1117,  1147,  1157,  1175,  1176,  1180,  1186,  1201,
  1202,  1206,  1215,  1219,  1220,  1228,  1230,  1250,  1251,  1255,
  1259,  1273,  1277,  1284,  1285,  1289,  1307,  1314,  1315,  1319,
  1323,  1330,  1331,  1335,  1342,  1346,  1356,  1357,  1364,  1365,
  1376,  1378,  1380,  1382,  1384,  1392,  1398,  1404,  1413,  1417,
  1422,  1431,  1440,  1448,  1464,  1465,  1466,  1477,  1478,  1479,
  1480,  1481,  1482,  1486,  1487,  1488,  1492,  1493,  1497,  1498,
  1502,  1504,  1506,  1515,  1516,  1520,  1532,  1540,  1544,  1551,
  1552,  1560,  1561,  1562,  1563,  1564,  1565,  1566,  1588,  1589,
  1593,  1594,  1595,  1596,  1601,  1602,  1603,  1622,  1627,  1631,
  1635,  1639,  1646,  1647,  1648,  1649,  1653,  1654,  1655,  1656,
  1660,  1662,  1664,  1666,  1668,  1670,  1672,  1674,  1676,  1678,
  1680,  1682,  1688,  1713,  1730,  1737,  1744,  1754,  1755,  1759,
  1761,  1768,  1778,  1779,  1783,  1794,  1796,  1798,  1802,  1806,
  1810,  1817,  1826,  1833,  1840,  1842,  1846,  1850,  1854
};

static const char * const yytname[] = {   "$","error","$undefined.","TOK_ALL",
"TOK_ALTER","TOK_ANY","TOK_AS","TOK_ASC","TOK_AUTHORIZATION","TOK_BEGIN","TOK_BETWEEN",
"TOK_BY","TOK_CHECK","TOK_CLOSE","TOK_COBOL_LANG","TOK_C_LANG","TOK_COMMIT",
"TOK_CONTINUE","TOK_CREATE","TOK_CURRENT","TOK_CURSOR","TOK_DECLARE","TOK_DEFAULT",
"TOK_DELETE","TOK_DESC","TOK_DISTINCT","TOK_DROP","TOK_END","TOK_ESCAPE","TOK_EXISTS",
"TOK_FETCH","TOK_FOR","TOK_FOREIGN","TOK_FORTRAN_LANG","TOK_FOUND","TOK_FROM",
"TOK_GOTO","TOK_GRANT","TOK_GROUP","TOK_HAVING","TOK_IN","TOK_INDICATOR","TOK_INSERT",
"TOK_INTO","TOK_IS","TOK_KEY","TOK_LANGUAGE","TOK_LIKE","TOK_MODULE","TOK_NULL",
"TOK_OF","TOK_ON","TOK_OPEN","TOK_OPTION","TOK_ORDER","TOK_PASCAL_LANG","TOK_PL1_LANG",
"TOK_PRIMARY","TOK_INDEX","TOK_PRIVILEGES","TOK_PROCEDURE","TOK_PUBLIC","TOK_REFERENCES",
"TOK_REVOKE","TOK_ROLLBACK","TOK_SCHEMA","TOK_SECTION","TOK_SELECT","TOK_SET",
"TOK_SOME","TOK_SQLCODE","TOK_SQLERROR","TOK_TABLE","TOK_TO","TOK_UNION","TOK_UNIQUE",
"TOK_UPDATE","TOK_USER","TOK_VALUES","TOK_VIEW","TOK_WHENEVER","TOK_WHERE","TOK_WITH",
"TOK_WORK","TOK_AND","TOK_OR","TOK_NOT","TOK_NE","TOK_GE","TOK_LE","TOK_AVG",
"TOK_MAX","TOK_MIN","TOK_SUM","TOK_COUNT","TOK_IDENTIFIER","TOK_PARAM","TOK_INTEGER_CONST",
"TOK_NUM_CONST","TOK_REAL_CONST","TOK_STRING_CONST","TOK_T_CHAR","TOK_T_NUM",
"TOK_T_INT","TOK_T_SINT","TOK_T_FLT","TOK_T_DOUBLE","TOK_T_PRECISION","TOK_T_REAL",
"UNARY","BRACETS","','","'+'","'-'","'*'","'/'","'.'","'('","')'","';'","'='",
"'<'","'>'","sql_compiled","tbl_or_view","dynamic","schema_title","schema_element",
"schema_action","basetable","basetable_def","basetableelement_list","basetableelement",
"column_descr","default_clause","def_clause","column_constrts","constr_list",
"column_constr","table_constr","table_constr1","unique_spec","refer_spec","opt_column_name_list",
"column_name_list","view","view_definition","opt_check_option","privilege_action",
"privilege","opt_grant","privileges","operation_list","operation","grantees",
"grantee_list","grantee","embedded_spec","declare_section","exception","exc_cond",
"exc_do","module_header","module_titl","lang_clause","autoriz_clause","cursor",
"procedure","orderby","orderspec_list","orderspec","sort_obj","sort_order","parameter_list",
"parameter","statement","statement_body","close_stmt","commit_stmt","delete_stmt",
"fetch_stmt","insert_stmt","insrt_tail","insertvalue_list","ins_value","open_stmt",
"roll_stmt","select_stmt","select_spec","update_stmt","assignment_list","assignment",
"assign_tail","expr_or_null","queryexpr","queryterm","queryspec","queryspec1",
"selection","expr_list","tableexpr","from","scan_list","scan_desc","where_d",
"where","where_cur","cursor_name","groupby","having","cond","pred","compare_to",
"comp_op","allany","not","esc","inin","atom_list","subquery","result_spec","all",
"expr","sign","prim","atom","funcref","fname","constant","type","table_def",
"table_desc","host_scan","tablename","column_list","column","target_list","target",
"target1","coltar",""
};
#endif

static const short yyr1[] = {     0,
   123,   123,   123,   123,   123,   123,   123,   123,   123,   124,
   124,   125,   125,   126,   127,   127,   127,   128,   128,   129,
   130,   131,   131,   132,   132,   133,   134,   134,   135,   135,
   135,   136,   136,   137,   137,   138,   138,   138,   138,   139,
   140,   140,   140,   141,   141,   141,   142,   143,   143,   144,
   144,   145,   146,   147,   147,   148,   148,   149,   150,   150,
   151,   151,   152,   152,   153,   153,   153,   153,   153,   154,
   154,   155,   155,   156,   157,   157,   158,   158,   159,   160,
   160,   161,   161,   162,   162,   163,   163,   164,   165,   166,
   167,   167,   167,   167,   167,   167,   168,   168,   169,   169,
   170,   171,   171,   172,   172,   172,   173,   173,   174,   174,
   175,   176,   176,   176,   176,   176,   176,   176,   176,   176,
   177,   178,   179,   179,   179,   180,   181,   182,   182,   183,
   183,   184,   185,   186,   187,   188,   188,   189,   189,   190,
   190,   191,   192,   193,   193,   194,   194,   195,   195,   196,
   197,   198,   198,   199,   199,   200,   201,   202,   202,   203,
   203,   204,   204,   205,   206,   207,   208,   208,   209,   209,
   210,   210,   210,   210,   210,   210,   210,   210,   211,   211,
   211,   211,   211,   211,   212,   212,   212,   213,   213,   213,
   213,   213,   213,   214,   214,   214,   215,   215,   216,   216,
   217,   217,   217,   218,   218,   219,   219,   220,   220,   221,
   221,   222,   222,   222,   222,   222,   222,   222,   223,   223,
   224,   224,   224,   224,   225,   225,   225,   225,   226,   226,
   226,   226,   227,   227,   227,   227,   228,   228,   228,   228,
   229,   229,   229,   229,   229,   229,   229,   229,   229,   229,
   229,   229,   230,   231,   232,   233,   233,   234,   234,   235,
   235,   235,   236,   236,   237,   238,   238,   238,   238,   238,
   238,   239,   239,   239,   239,   239,   239,   239,   239
};

static const short yyr2[] = {     0,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     3,     3,     1,     1,     1,     1,     1,     2,
     5,     1,     3,     1,     1,     4,     0,     2,     1,     1,
     1,     0,     1,     1,     2,     2,     3,     1,     2,     1,
     4,     6,     2,     1,     2,     1,     3,     0,     3,     1,
     3,     2,     6,     0,     3,     1,     1,     7,     0,     3,
     2,     1,     1,     3,     1,     1,     1,     2,     2,     1,
     1,     1,     3,     1,     1,     1,     3,     3,     3,     2,
     1,     1,     2,     3,     2,     2,     1,     2,     2,     6,
     6,     5,     5,     6,     3,     2,     0,     3,     1,     3,
     2,     1,     1,     0,     1,     1,     1,     3,     2,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     2,     2,     4,     2,     4,     4,     5,     4,     1,     1,
     3,     1,     2,     2,     6,     1,     1,     5,     5,     1,
     3,     3,     1,     1,     1,     1,     4,     1,     3,     3,
     4,     1,     1,     1,     3,     4,     2,     1,     3,     2,
     1,     0,     1,     2,     4,     1,     0,     3,     0,     2,
     1,     3,     3,     3,     2,     2,     2,     3,     2,     4,
     6,     5,     4,     3,     1,     1,     2,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     0,     1,     0,     2,
     1,     3,     3,     1,     3,     6,     4,     1,     1,     0,
     1,     1,     3,     3,     3,     3,     3,     2,     1,     1,
     1,     1,     1,     1,     1,     1,     2,     1,     4,     5,
     5,     5,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     2,     4,     1,     4,     1,
     4,     6,     1,     1,     1,     1,     3,     1,     3,     1,
     3,     5,     1,     3,     1,     1,     1,     3,     2,     3,
     2,     1,     3,     5,     1,     3,     2,     3,     2
};

static const short yydefact[] = {     0,
     9,    19,     0,     0,     0,    18,     0,     0,     0,     0,
     0,    56,     0,    87,     0,     0,    57,     0,   210,     0,
     0,     0,     8,     1,     2,     0,    15,    16,     0,    17,
     6,    75,    76,     3,     0,     4,     5,     7,   111,   112,
   113,   114,   115,   116,   117,   118,   119,   120,    12,   146,
   148,    96,     0,   166,   121,   122,     0,    52,     0,     0,
     0,   124,    10,    11,     0,     0,     0,     0,    86,   133,
     0,     0,   134,   211,   137,     0,   136,   256,   255,     0,
   254,    81,     0,     0,   210,     0,     0,     0,     0,    20,
     0,    67,    66,    48,    65,    48,     0,    62,    63,    85,
     0,     0,   210,    77,    48,   253,     0,   162,     0,    13,
    78,     0,    48,    95,   110,     0,     0,     0,   107,   224,
   233,   234,   235,   236,     0,   272,   275,   237,   239,   238,
   240,   219,   220,   153,     0,     0,   152,   154,     0,   212,
   223,     0,   222,   221,     0,     0,    80,    82,     0,    79,
     0,   149,   150,     0,    14,     0,    61,     0,    69,    68,
     0,     0,    88,    84,     0,     0,     0,     0,   123,   163,
   125,     0,   266,   267,   126,   263,   265,     0,   241,   250,
   243,   242,   248,   245,   244,   109,     0,     0,     0,     0,
     0,     0,   277,     0,     0,   279,     0,     0,     0,     0,
     0,     0,     0,   218,   210,   257,     0,   162,   140,    83,
     0,    89,     0,    50,     0,     0,    64,   147,     0,    97,
     0,     0,     0,   272,     0,   164,   171,   197,     0,   165,
     0,   269,     0,   271,     0,     0,     0,   127,   129,     0,
     0,     0,   246,    93,    92,   108,     0,     0,     0,     0,
   276,   273,   278,   213,     0,   155,   214,   215,   216,   217,
     0,     0,     0,     0,   138,   139,     0,   151,   162,     0,
     0,     0,    46,    44,     0,     0,    22,    24,    25,    40,
     0,     0,    49,     0,    54,     0,    90,   177,   176,     0,
   179,   175,     0,     0,     0,   197,     0,     0,   198,   189,
   193,   192,   188,   190,   191,     0,     0,   197,   268,   270,
   264,     0,     0,     0,     0,    94,    91,   260,     0,   229,
     0,   135,     0,     0,   145,   142,   143,   144,   141,   157,
   158,   161,     0,   167,    43,     0,    45,    27,     0,    21,
     0,    51,    71,    74,    59,    70,    72,     0,    53,     0,
     0,   273,   178,   172,   174,   173,   194,   195,   196,     0,
   184,     0,   186,   185,     0,     0,     0,     0,     0,   130,
   132,   249,     0,   251,   247,     0,   230,   274,   231,   232,
     0,   160,     0,   169,     0,     0,    32,    23,     0,     0,
    58,     0,     0,   102,    98,    99,   104,   103,     0,     0,
     0,   187,     0,     0,   183,   201,   228,     0,   199,   226,
   225,   180,     0,   128,     0,   261,   159,     0,     0,   156,
     0,    30,    29,    28,    31,     0,     0,     0,    26,    33,
    34,    38,    41,     0,    73,    55,     0,   105,   106,   101,
   207,   209,     0,   208,   274,     0,     0,     0,   204,   227,
     0,   182,   131,   252,     0,   168,   258,   170,     0,    39,
    48,    36,    35,    60,   100,     0,   181,   203,     0,   202,
   200,   262,     0,    42,    47,    37,   206,   205,   259,     0,
     0,     0
};

static const short yydefgoto[] = {   480,
    65,    23,    24,    25,    26,    27,    90,   276,   277,   278,
   387,   424,   429,   430,   431,   279,   280,   281,   432,   159,
   215,    28,    58,   349,    29,    30,   391,    97,    98,    99,
   345,   346,   347,    31,    32,    33,    84,   150,    34,    35,
   102,   155,    36,    37,   287,   395,   396,   397,   440,   118,
   119,    38,    39,    40,    41,    42,    43,    44,   238,   369,
   370,    45,    46,    47,    76,    48,   208,   209,   326,   371,
    49,    50,    51,    87,   136,   137,   268,   269,   330,   331,
   169,   170,    62,    55,   384,   420,   226,   227,   361,   306,
   362,   307,   452,   405,   448,   291,   443,    77,   228,   139,
   140,   409,   141,   142,   143,   186,   105,    79,    80,    81,
   456,   229,   175,   176,   411,   144
};

static const short yypact[] = {    24,
   -75,-32768,    35,   -35,    59,    67,    56,    96,   -26,   154,
   -35,-32768,   189,   142,   -35,    37,-32768,   202,   171,   185,
   113,   -36,-32768,-32768,-32768,   170,-32768,-32768,   244,-32768,
-32768,-32768,-32768,-32768,    28,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   219,-32768,
-32768,-32768,   248,-32768,-32768,-32768,   185,-32768,   290,   185,
   296,-32768,-32768,-32768,   185,   253,   279,   185,-32768,-32768,
   206,   -27,-32768,-32768,-32768,   372,-32768,   222,-32768,   288,
-32768,-32768,   313,    22,   171,    79,   257,   355,   185,-32768,
   312,-32768,-32768,   262,-32768,   262,   337,   285,-32768,-32768,
   302,   355,   396,-32768,   262,-32768,   369,   320,   362,-32768,
-32768,   155,   262,-32768,-32768,   281,   338,   -62,-32768,-32768,
-32768,-32768,-32768,-32768,   294,    60,     7,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   411,   370,   305,   317,   411,-32768,
-32768,   333,-32768,-32768,   342,   380,-32768,-32768,   381,-32768,
   372,-32768,-32768,   384,-32768,   363,-32768,   386,-32768,-32768,
   185,   245,-32768,-32768,   365,   477,   365,    66,-32768,-32768,
-32768,   -35,    -6,    23,   376,-32768,-32768,   -48,   398,   399,
-32768,-32768,   405,   418,-32768,-32768,   407,   408,    75,   339,
   -12,   438,-32768,   439,   440,-32768,   280,   155,   411,   411,
   411,   411,   411,-32768,   200,-32768,   419,   -49,-32768,-32768,
   502,-32768,   197,-32768,   135,   465,-32768,-32768,   423,   148,
   224,   424,   121,   -17,   166,   289,-32768,   321,   498,-32768,
   448,-32768,   452,-32768,   155,   434,   482,-32768,-32768,   458,
   459,   460,-32768,-32768,-32768,-32768,   441,   442,   463,   444,
-32768,   443,-32768,-32768,   -21,   317,   263,   263,-32768,-32768,
   463,   411,   327,   380,-32768,-32768,   185,-32768,   483,   121,
   518,   520,-32768,-32768,   281,   177,-32768,-32768,-32768,-32768,
   449,   472,-32768,   111,   486,   558,-32768,-32768,-32768,   503,
-32768,-32768,   476,    63,   164,   432,   121,   121,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,   236,   230,   487,-32768,-32768,
-32768,   327,   454,   179,   456,-32768,-32768,   461,   457,-32768,
   481,-32768,   462,   417,-32768,-32768,-32768,   317,-32768,   467,
-32768,   484,   121,   543,   289,   466,-32768,   560,   197,-32768,
   386,-32768,-32768,-32768,   504,   473,-32768,   573,-32768,   199,
    16,    21,-32768,-32768,-32768,   505,-32768,-32768,-32768,   361,
-32768,   424,-32768,   317,   411,   470,   246,   539,   180,-32768,
-32768,-32768,   493,-32768,-32768,   496,-32768,-32768,-32768,-32768,
   185,-32768,   581,   554,   386,    91,     8,-32768,   239,   557,
-32768,   500,   544,-32768,   485,-32768,   186,-32768,   480,   400,
   506,-32768,   161,   204,-32768,-32768,-32768,   348,   571,-32768,
-32768,-32768,   327,-32768,   488,   489,-32768,   463,   121,-32768,
   249,-32768,-32768,-32768,-32768,   121,   185,   551,-32768,     8,
-32768,-32768,-32768,   549,-32768,-32768,   199,-32768,-32768,-32768,
-32768,-32768,   502,   317,   559,   411,   490,   254,-32768,-32768,
   246,-32768,-32768,-32768,   509,   499,-32768,   289,   545,   289,
   262,   169,-32768,-32768,-32768,   491,   317,-32768,   246,-32768,
-32768,-32768,   463,-32768,-32768,-32768,-32768,-32768,-32768,   611,
   612,-32768
};

static const short yypgoto[] = {-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   274,-32768,
-32768,-32768,-32768,-32768,   184,-32768,-32768,   153,   157,   -95,
  -161,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   455,
-32768,-32768,   226,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   517,-32768,-32768,-32768,-32768,   183,-32768,-32768,-32768,
   433,   -94,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   208,-32768,-32768,-32768,   -82,-32768,-32768,   359,-32768,   364,
   -13,   464,   -34,-32768,   474,-32768,  -249,-32768,-32768,   243,
  -186,-32768,   -87,    -3,-32768,-32768,  -218,-32768,-32768,-32768,
-32768,   318,-32768,-32768,-32768,  -280,-32768,   -88,   -76,  -333,
-32768,  -269,-32768,-32768,  -331,   353,   541,   -63,   163,    82,
-32768,  -245,   435,   397,  -101,-32768
};


#define	YYLAST		633


static const short yytable[] = {   138,
   160,   110,   151,   319,   292,   322,   295,    67,    86,   166,
   177,    70,   249,   267,   165,   323,   399,   178,    74,   426,
   171,   265,   188,   192,     1,   363,  -260,     2,   100,   236,
    85,   168,     3,   408,   231,   410,     4,    71,   148,     5,
    75,     6,   115,    52,     7,    63,     8,   195,   189,     9,
    10,   335,    64,    11,   425,    53,   190,   149,   197,    54,
    12,   264,   204,   233,  -261,    13,   221,   116,   237,   427,
   408,    14,   410,   101,   138,    15,   450,   193,   355,   356,
    22,   402,   334,    16,   109,   406,    17,    18,   232,   235,
    19,   117,  -210,   428,   222,   248,   177,   216,   293,    20,
   192,   250,   196,    21,   398,  -210,  -210,  -210,  -210,  -210,
  -210,  -210,  -210,  -210,  -210,  -210,   262,   408,   234,   410,
   266,   221,   256,   257,   258,   259,   260,  -210,  -210,  -210,
    60,    72,  -210,   177,   449,   408,   401,   410,   106,   422,
    22,    56,   120,   239,   115,    57,   288,   289,   296,   222,
    59,   223,   103,   220,   193,   121,   122,   123,   124,   125,
   224,   127,   128,   129,   130,   131,   294,   423,   230,   116,
   106,   343,   457,    74,    66,   194,    61,   132,   133,   389,
   353,   471,   225,    82,   285,   324,   328,   128,   129,   130,
   131,   398,   438,   466,   222,    75,   152,   120,    83,   478,
   458,   286,    74,   332,   447,   344,   223,   460,   270,   439,
   121,   122,   123,   124,   125,   224,   127,   128,   129,   130,
   131,   103,   108,   421,   261,   272,   273,   479,   271,   364,
   113,    68,   132,   133,    88,   328,    69,   225,   357,   365,
   358,    89,   120,   274,   446,   282,    91,   297,   298,   173,
   174,   223,   283,   272,   273,   121,   122,   123,   124,   125,
   224,   127,   128,   129,   130,   131,    92,    92,   400,   366,
   351,   274,   200,   201,   202,   203,   367,   132,   133,    78,
   407,   354,   225,   197,    73,    93,    93,   339,   403,   373,
   413,   275,   103,   318,   340,   394,   374,   414,   173,   174,
   128,   129,   130,   131,   359,    94,    94,   288,   289,   107,
    95,    95,   120,   104,   109,   132,   133,   332,   111,    96,
    96,   112,   407,   444,   114,   121,   122,   123,   124,   125,
   126,   127,   128,   129,   130,   131,   328,   145,   187,   247,
   173,   174,   128,   129,   130,   131,   147,   132,   133,   282,
     4,     4,   360,     5,     5,   146,   433,   132,   133,   282,
     8,     8,   154,   461,   469,   475,   459,    11,    11,   467,
   157,   470,   297,   298,   153,   325,   202,   203,   158,    13,
    13,   179,   180,   181,   182,   183,   184,   161,   185,    15,
    15,   200,   201,   202,   203,   162,   163,   254,    74,   167,
   168,    18,    18,   120,    19,    19,   299,   300,   301,   302,
   191,   172,   198,    20,    20,   199,   121,   122,   123,   124,
   125,   126,   127,   128,   129,   130,   131,   351,   200,   201,
   202,   203,   200,   201,   202,   203,   206,   120,   132,   133,
   303,   304,   305,   135,   128,   129,   130,   131,   120,   205,
   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
   131,   121,   122,   123,   124,   125,   126,   127,   128,   129,
   130,   131,   132,   133,   207,   210,   120,   135,   212,   213,
   214,    22,   219,   132,   133,   134,   235,   120,   135,   121,
   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,
   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
   131,   132,   133,   442,   240,   241,   135,   299,   300,   301,
   302,   242,   132,   133,   243,   244,   245,   135,   200,   201,
   202,   203,   251,   252,   380,   253,   267,   284,   263,   237,
   290,   308,   309,   200,   201,   202,   203,   310,    85,   254,
   312,   303,   304,   305,   313,   314,   315,   318,   321,   316,
   317,   320,   336,   333,   337,   341,   342,   348,   350,   351,
   352,   372,   299,   375,   377,   378,   376,   381,   382,   379,
   383,   386,   385,   392,   393,   390,   404,   412,   297,   415,
   416,   418,   419,   434,   344,   437,   436,   441,   451,   462,
   445,   464,  -262,   472,   455,   454,   427,   468,   477,   473,
   481,   482,   388,   463,   476,   474,   217,   435,   164,   465,
   453,   246,   329,   417,   211,   368,   327,   338,   218,   156,
     0,   311,   255
};

static const short yycheck[] = {    76,
    96,    65,    85,   249,   223,   255,   225,    11,    22,   105,
   112,    15,    25,    35,   103,   261,     1,   113,     3,    12,
   108,   208,   117,    41,     1,   306,    44,     4,     1,    78,
    67,    81,     9,   367,    41,   367,    13,     1,    17,    16,
    25,    18,    70,   119,    21,    72,    23,    41,   111,    26,
    27,   270,    79,    30,   386,    21,   119,    36,   135,    95,
    37,   111,   139,    41,    44,    42,     1,    95,   117,    62,
   404,    48,   404,    46,   151,    52,   408,    95,   297,   298,
   117,   362,   269,    60,    19,   366,    63,    64,    95,   111,
    67,   119,    77,    86,    29,   190,   198,   161,   116,    76,
    41,   114,    96,    80,   350,    90,    91,    92,    93,    94,
    95,    96,    97,    98,    99,   100,   205,   451,    96,   451,
   208,     1,   199,   200,   201,   202,   203,   112,   113,   114,
    35,    95,   117,   235,   404,   469,   116,   469,    57,    49,
   117,    83,    77,   178,    70,    79,    84,    85,   225,    29,
    95,    86,    74,   167,    95,    90,    91,    92,    93,    94,
    95,    96,    97,    98,    99,   100,     1,    77,   172,    95,
    89,    61,   418,     3,    21,   116,    81,   112,   113,   341,
   118,   451,   117,    71,   219,   262,   263,    97,    98,    99,
   100,   437,     7,   443,    29,    25,   118,    77,    86,   469,
   419,    54,     3,   267,     1,    95,    86,   426,    12,    24,
    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
   100,    74,    60,   385,    25,    57,    58,   473,    32,   306,
    68,    43,   112,   113,    65,   312,    95,   117,     3,    10,
     5,    72,    77,    75,    84,   111,     3,    84,    85,    95,
    96,    86,   118,    57,    58,    90,    91,    92,    93,    94,
    95,    96,    97,    98,    99,   100,    23,    23,   351,    40,
    67,    75,   112,   113,   114,   115,    47,   112,   113,    95,
    77,   118,   117,   360,    83,    42,    42,   111,   365,   111,
   111,    95,    74,    95,   118,    97,   118,   118,    95,    96,
    97,    98,    99,   100,    69,    62,    62,    84,    85,    20,
    67,    67,    77,    66,    19,   112,   113,   381,    66,    76,
    76,    43,    77,   400,   119,    90,    91,    92,    93,    94,
    95,    96,    97,    98,    99,   100,   413,   116,     1,     1,
    95,    96,    97,    98,    99,   100,    34,   112,   113,   111,
    13,    13,   117,    16,    16,    68,   118,   112,   113,   111,
    23,    23,     8,   427,   111,   461,   118,    30,    30,   446,
    59,   118,    84,    85,   118,    49,   114,   115,   117,    42,
    42,   101,   102,   103,   104,   105,   106,    51,   108,    52,
    52,   112,   113,   114,   115,   111,    95,   118,     3,    31,
    81,    64,    64,    77,    67,    67,    86,    87,    88,    89,
   117,    50,    43,    76,    76,   111,    90,    91,    92,    93,
    94,    95,    96,    97,    98,    99,   100,    67,   112,   113,
   114,   115,   112,   113,   114,   115,    95,    77,   112,   113,
   120,   121,   122,   117,    97,    98,    99,   100,    77,   117,
    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
   100,    90,    91,    92,    93,    94,    95,    96,    97,    98,
    99,   100,   112,   113,    95,    95,    77,   117,    95,   117,
    95,   117,     6,   112,   113,   114,   111,    77,   117,    90,
    91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
   100,   112,   113,   114,   117,   117,   117,    86,    87,    88,
    89,   117,   112,   113,   107,   119,   119,   117,   112,   113,
   114,   115,    95,    95,   118,    96,    35,    73,   120,   117,
   117,    44,    95,   112,   113,   114,   115,    96,    67,   118,
   117,   120,   121,   122,    97,    97,    97,    95,   116,   119,
   119,   118,    45,    81,    45,   117,    95,    82,    11,    67,
    95,   118,    86,   118,   118,    95,   116,   111,    95,   118,
    38,    22,   117,   111,    12,    82,   117,    49,    84,    97,
    95,    11,    39,    37,    95,   111,    53,   118,    28,    49,
    95,    53,    44,    95,   116,   118,    62,   118,   118,   111,
     0,     0,   339,   430,   462,   459,   162,   392,   102,   437,
   413,   189,   264,   381,   151,   308,   263,   275,   165,    89,
    -1,   235,   198
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */


/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif



/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#else
#define YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#endif

int
yyparse(YYPARSE_PARAM)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:

{ 
      if (progname && *progname)
        yyerror ("Unexpected schema operation in static mode compilation ");
      else if (parse_mode==Module)
        yyerror ("Unexpected schema operation inside module");
      if(yyvsp[0].code)
        parse_mode=Schema;
    ;
    break;}
case 2:

{ 
      if (progname && *progname)
        yyerror ("Unexpected schema operation in static mode compilation ");
      else if (parse_mode==Module)
        yyerror ("Unexpected schema operation inside module");
    ;
    break;}
case 3:

{ if (yyvsp[0].code) parse_mode=Module; ;
    break;}
case 4:

{ ; ;
    break;}
case 5:

{ 
      if(parse_mode!=Module)
        yyerror("Unexpected module operation outside module");
    ;
    break;}
case 6:

{ ; ;
    break;}
case 7:

{
      if(parse_mode==Esql)
        {
          free_tail();
          yyval.code=0;
        }
    ;
    break;}
case 8:

{;
    break;}
case 9:

{
      yyerror("Error: unrecognizable SQL construction in input file");
      free_tail();
      YYERROK; yyclearin;
      YYACCEPT;
    ;
    break;}
case 10:

{ yyval.code = TABLE; ;
    break;}
case 11:

{ yyval.code = VIEW;  ;
    break;}
case 12:

{
      TXTREF c,d = gen_parent(DECL_CURS,yyvsp[0].node);
      STMT_VCB(d) = LOCAL_VCB_ROOT;
      SetF_TRN(d,HAS_VCB_F);
      LOCAL_VCB_ROOT = TNULL;
      c = gen_parent(CUR_AREA,d);
      add_statement(c);
      d = gen_node(CURSOR);
      if (dyn_sql_stmt_name)
        CUR_NAME(d) = ltr_rec(dyn_sql_stmt_name);
      else
        yyfatal("Attemp to compile unnamed statement");
      CUR_DECL(d) = c;
      STMT_VCB(c) = d;
      yyval.code = 0;
    ;
    break;}
case 13:

{
       TXTREF d = gen_object(DROP,yylsp[-2]);
       CREATE_OBJ(d) = yyvsp[0].node;
       CODE_TRN(yyvsp[0].node) = yyvsp[-1].code;
       add_statement(d);
     ;
    break;}
case 14:

{ {
     add_statement(gen_object(yyvsp[-2].code,yylsp[-1]));
     yyval.code = 0;
   } ;
    break;}
case 18:

{ yyval.code=CREATE; ;
    break;}
case 19:

{ yyval.code=ALTER; ;
    break;}
case 20:

{
       register TXTREF e=gen_object(yyvsp[-1].code,yylsp[-1]);
       CREATE_OBJ(e)=yyvsp[0].node;
       add_statement(e);
       yyval.code=STMT_UID(e);
     ;
    break;}
case 21:

{
      register TXTREF t=yyvsp[-3].node,e=yyvsp[-1].node;
      if (!t)
        free_line (e);
      else if (new_table != t)
        yyfatal ("Internal error: unexpected 'new_table'");
      else
        {
          CODE_TRN (t) = TABLE;
	  TBL_NCOLS(t) = new_table_col_no;
          SetF_TRN (t, CHECKED_F);
          new_table = TNULL;
        }
      yyval.node=t;
    ;
    break;}
case 22:

{ yyval.node=yyvsp[0].node;;
    break;}
case 23:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 24:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 25:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 26:

{
      if(new_table)
        add_base_column(yyvsp[-3].ltrp,yyvsp[-2].type,yyvsp[-1].node,yyvsp[0].node);
      yyval.node = TNULL;
    ;
    break;}
case 27:

{ yyval.node = TNULL;     ;
    break;}
case 28:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 29:

{
      yyval.node = gen_object (USERNAME, yylsp[0]);
      USR_NAME (yyval.node) = yyvsp[0].ltrp;
    ;
    break;}
case 30:

{ yyval.node = gen_object (NULL_VL, yylsp[0]); ;
    break;}
case 31:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 32:

{ yyval.node = TNULL;        ;
    break;}
case 33:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 34:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 35:

{ yyval.node = join_list(yyvsp[-1].node,yyvsp[0].node); ;
    break;}
case 36:

{ yyval.node = gen_object (NULL_VL, yylsp[0]); ;
    break;}
case 37:

{ yyval.node = gen_object (yyvsp[0].code, yylsp[0]); ;
    break;}
case 38:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 39:

{
      yyval.node = gen_up_node (CHECK, yyvsp[0].node, yylsp[-1]);
    ;
    break;}
case 40:

{{
      if(!new_table)
        yyerror("Unexpected constraints");
      else
	switch(CODE_TRN(yyvsp[0].node))
	  {
          case NULL_VL:
            yyfatal("Unexpected NULL_VL node");
            break;
	  case PRIMARY:
	  case UNIQUE:
            check_not_null(yyvsp[0].node);
	  case INDEX:
	    IND_INFO(new_table)=
	      join_list(IND_INFO(new_table),yyvsp[0].node);
	    break;
	  default:
            RIGHT_TRN(yyvsp[0].node) = TNULL;
	    TBL_CONSTR(new_table)=
	      join_list(TBL_CONSTR(new_table),yyvsp[0].node);
	  }
      yyval.node = TNULL;
    };
    break;}
case 41:

{
      yyval.node=gen_up_node(yyvsp[-3].code,
                           replace_column_holes(yyvsp[-1].node,new_table),
                           yylsp[-3]);
    ;
    break;}
case 42:

{
      yyval.node=
        gen_up_node(FOREIGN,
                    join_list(gen_parent(LOCALLIST,
                                         replace_column_holes(yyvsp[-2].node,
                                                              new_table)),
                              yyvsp[0].node),
                    yylsp[-5]);
    ;
    break;}
case 43:

{
      yyval.node=gen_up_node(CHECK,
                           replace_column_holes(yyvsp[0].node,
                                                new_table),
                           yylsp[-1]);
    ;
    break;}
case 44:

{ yyval.code=UNIQUE; ;
    break;}
case 45:

{ yyval.code=PRIMARY; ;
    break;}
case 46:

{ yyval.code=INDEX; ;
    break;}
case 47:

{ {
      TXTREF t = gen_object(OPTR,yylsp[-2]);
      OBJ_DESC(t)  = yyvsp[-1].node;
      yyval.node = gen_up_node(REFERENCE,
                             join_list(t,gen_parent(NOOP,yyvsp[0].node)),
                             yylsp[-2]);
    } ;
    break;}
case 48:

{ yyval.node=0; ;
    break;}
case 49:

{ yyval.node=yyvsp[-1].node;;
    break;}
case 50:

{
      yyval.node=gen_column(NULL,yyvsp[0].ltrp,yylsp[0]);
    ;
    break;}
case 51:

{
      yyval.node=join_list(yyvsp[-2].node,gen_column(NULL,yyvsp[0].ltrp,yylsp[0]));
    ;
    break;}
case 52:

{
      register TXTREF e;
      e=gen_object(CREATE,yylsp[-1]);
      CREATE_OBJ(e)=yyvsp[0].node;
      add_statement(e);
      yyval.code=STMT_UID(e);
    ;
    break;}
case 53:

{
      register TXTREF t = yyvsp[-4].node, e= yyvsp[-3].node;
      if(!t)
        free_line (e);
      else
        {
          TXTREF     c;
          sql_type_t type  = pack_type(SQLType_0,0,0);
          i4_t        e_cnt = count_list (e);
          
          TXTREF sel_node = RIGHT_TRN (DOWN_TRN (yyvsp[-1].node));
          
          CODE_TRN (t) = VIEW;

          if (e)
            if (e_cnt != ARITY_TRN (sel_node))
              {
                yyerror("Incorrect number of columns in VIEW defenition");
                free_line(e);
                e = TNULL;
              }
          if (e)
            {
              for ( c = e ; c ; c = RIGHT_TRN(c))
                add_view_column(CHOLE_CNAME(OBJ_DESC(c)),type);
              free_line (e);
            }
          else
            {
              for ( c = DOWN_TRN(sel_node) ; c ; c = RIGHT_TRN(c))
                {
                  if (CODE_TRN(c) == COLPTR)
                    add_view_column(CHOLE_CNAME(OBJ_DESC(c)),type);
                  else
                    yyerror("Expressions aren't allowed in selection list"
                            " of anonimous view");
                }
            }
          /* TASSERT(new_table_col_no == ARITY_TRN(sel_node),sel_node); */
	  TBL_NCOLS(t) = ARITY_TRN(sel_node);
            
          VIEW_QUERY (t) = yyvsp[-1].node;
          if(yyvsp[0].code) SetF_TRN (t, CHECK_OPT_F);
          SetF_TRN (t, CHECKED_F);
          VIEW_VCB (t) = LOCAL_VCB_ROOT;
          LOCAL_VCB_ROOT = TNULL;
          new_table = TNULL;
        }
      yyval.node=t;
    ;
    break;}
case 54:

{ yyval.code=0; ;
    break;}
case 55:

{ yyval.code=1; ;
    break;}
case 56:

{ yyval.code=GRANT; ;
    break;}
case 57:

{ yyval.code=REVOKE; ;
    break;}
case 58:

{
      register TXTREF p,g;
      register i4_t    err = errors;
      
      p=replace_column_holes(yyvsp[-5].node,yyvsp[-3].node);
      p = gen_parent(PRIVILEGIES, p);

      if (errors != err) /* if there was some error in the tree */
        {
          g =  gen_parent(GRANTEES, yyvsp[-1].node);
          debug_trn(p);
          free_tree(p);
          debug_trn(g);
          free_tree(g);
        }
      else
        {
          g=gen_node(TBLPTR);
          TABL_DESC(g) = yyvsp[-3].node;
          g=gen_up_node(yyvsp[-6].code,
                        join_list(g,       
                                  join_list(p,
                                            gen_parent(GRANTEES,
                                                       yyvsp[-1].node))),
                        yylsp[-6]);
          if(yyvsp[0].code)
            SetF_TRN(g,GRANT_OPT_F);
          add_statement(g);
          yyval.code=STMT_UID(g);
        }
    ;
    break;}
case 59:

{ yyval.code=0; ;
    break;}
case 60:

{ yyval.code=1; ;
    break;}
case 61:

{ yyval.node=0; ;
    break;}
case 62:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 63:

{ yyval.node=yyvsp[0].node;;
    break;}
case 64:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 65:

{ yyval.node = gen_object(SELECT,yylsp[0]); ;
    break;}
case 66:

{ yyval.node = gen_object(INSERT,yylsp[0]); ;
    break;}
case 67:

{ yyval.node = gen_object(DELETE,yylsp[0]); ;
    break;}
case 68:

{ yyval.node = gen_up_node(UPDATE,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 69:

{ yyval.node = gen_up_node(REFERENCE,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 70:

{ yyval.node = yyvsp[0].node;                  ;
    break;}
case 71:

{
      register TXTREF u=gen_object(USERNAME,yylsp[0]);
      USR_NAME(u)=ltr_rec("PUBLIC");
      yyval.node=u;
    ;
    break;}
case 72:

{ yyval.node=yyvsp[0].node;;
    break;}
case 73:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 74:

{
      register TXTREF u=gen_object(USERNAME,yylsp[0]);
      USR_NAME(u)=yyvsp[0].ltrp;
      yyval.node=u;
    ;
    break;}
case 75:

{ ; ;
    break;}
case 76:

{ ; ;
    break;}
case 77:

{ yyval.code=1; ;
    break;}
case 78:

{ yyval.code=0; ;
    break;}
case 79:

{
     *( yyvsp[-1].code ? &label_nf : &label_er ) =
       ( yyvsp[0].ltrp ? (STRING(yyvsp[0].ltrp)) : NULL );
   ;
    break;}
case 80:

{ yyval.code=1; ;
    break;}
case 81:

{ yyval.code=0; ;
    break;}
case 82:

{ yyval.ltrp=0; ;
    break;}
case 83:

{ yyval.ltrp=yyvsp[0].ltrp; ;
    break;}
case 84:

{ yyval.code=1; ;
    break;}
case 85:

{
      YYERROK;
      yyerror("Error in module title");
      yyval.code=0;
    ;
    break;}
case 86:

{ yyval.code=0; ;
    break;}
case 87:

{ yyval.code=0; ;
    break;}
case 88:

{
      if (strncmp("C",STRING(yyvsp[0].ltrp),1)==0)
        yyval.code=0;
      else
        {
          lperror("SQL module for %s program can't be processed yet",
                  STRING(yyvsp[0].ltrp));
          YYABORT;
        }
    ;
    break;}
case 89:

{ {
     extern char *current_user_login_name;
     char *s, *s1;

     s1 = current_user_login_name;
     current_user_login_name = NULL;
     s = get_user_name ();
     current_user_login_name = s1;
     

     if(GL_AUTHOR && (GL_AUTHOR!=yyvsp[0].ltrp) && s &&
        (strcmp(STRING(GL_AUTHOR),s)))
       yyerror("Incorrect user identifier");
     else
       GL_AUTHOR=yyvsp[0].ltrp;
   } ;
    break;}
case 90:

{
      register TXTREF c,d;
      d=gen_up_node(DECL_CURS,join_list(yyvsp[-1].node,yyvsp[0].node),yylsp[-5]);
      STMT_VCB(d)=LOCAL_VCB_ROOT;
      SetF_TRN(d,HAS_VCB_F);
      LOCAL_VCB_ROOT = TNULL;
      d=gen_up_node(CUR_AREA,d,yylsp[-5]);
      add_statement(d);

      c=gen_node(CURSOR);
      CUR_DECL(c)=d;
      CUR_NAME(c)=yyvsp[-4].ltrp;
      STMT_VCB(d)=c;

      if(find_info(CURSOR,CUR_NAME(c)))
        {
          char cn[512];
          lperror("Static cursor name '%s' redeclaration",STRING(CUR_NAME(c)));
          sprintf(cn,"%s_1",STRING(CUR_NAME(c)));
          CUR_NAME(c) = ltr_rec(cn);
        }
      add_info(c);
      yyval.code=0;
    ;
    break;}
case 91:

{
      emit_module_proc(yyvsp[-3].node,yyvsp[-4].ltrp);
      free_line(yyvsp[-3].node);
      yyval.code=0;
    ;
    break;}
case 92:

{
      emit_module_proc(LOCAL_VCB_ROOT,yyvsp[-3].ltrp);
      yyval.code=0;
    ;
    break;}
case 93:

{
      YYERROK;
      yyerror("Error in procedure's body");
    ;
    break;}
case 94:

{
      YYERROK;
      yyerror("Error in procedure's body");
    ;
    break;}
case 95:

{
      YYERROK;
      yyerror("Error in procedure's title");
    ;
    break;}
case 96:

{
      YYERROK;
      yyerror("Error: unexpected \';\' found before procedure title");
    ;
    break;}
case 97:

{ yyval.node = TNULL;;
    break;}
case 98:

{ yyval.node = gen_up_node (ORDER, yyvsp[0].node, yylsp[-2]); ;
    break;}
case 99:

{ yyval.node=yyvsp[0].node;;
    break;}
case 100:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 101:

{
      if(yyvsp[0].code)SetF_TRN(yyvsp[-1].node,DESC_F);
      yyval.node=yyvsp[-1].node;
    ;
    break;}
case 102:

{ register TXTREF n=gen_object(SORT_POS,yylsp[0]);
      SORT_IND(n)= atol(STRING(CNST_NAME(yyvsp[0].node))) - 1;
      free_node(yyvsp[0].node);
      yyval.node=n;
    ;
    break;}
case 103:

{
      register TXTREF s=gen_node(SORT_COL);
      SORT_CLM(s)=yyvsp[0].node;
      yyval.node=s;
    ;
    break;}
case 104:

{ yyval.code=0; ;
    break;}
case 105:

{ yyval.code=0; ;
    break;}
case 106:

{ yyval.code=1; ;
    break;}
case 107:

{ yyval.node=yyvsp[0].node;              ;
    break;}
case 108:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 109:

{
     register TXTREF n;
     n=get_param(yyvsp[-1].ltrp,0,yylsp[-1]);
     if(!n)
       yyfatal("can`t add parameter");
     if(TstF_TRN(n,CHECKED_F))
       yyval.node = TNULL;
     else
       {
         PAR_STYPE(n)=yyvsp[0].type;
         SetF_TRN(n,CHECKED_F);
         n=copy_trn(n);
         RIGHT_TRN(n)=0;
         ClrF_TRN(n,VCB_F);
         yyval.node=n;
       }
   ;
    break;}
case 110:

{
     register TXTREF n;
     n=get_param(ltr_rec("SQLCODEP"),0,yylsp[0]);
     if(!n)
       yyfatal("can`t add parameter");
     if(TstF_TRN(n,CHECKED_F))
       yyval.node = TNULL;
     else
       {
         PAR_STYPE(n)=pack_type(SQLType_Int,0,0);
         SetF_TRN(n,CHECKED_F);
         SetF_TRN(n,OUT_F);
         n=copy_trn(n);
         RIGHT_TRN(n)=0;
         ClrF_TRN(n,VCB_F);
         yyval.node=n;
       }
   ;
    break;}
case 111:

{
      register TXTREF u=yyvsp[0].node;
      if(subquery)
        fprintf(stderr,
                "Internal warning parse.y: Subquery flag not processed\n");
      subquery=0;
      if (u != FICTIVE_NODE)
        {
          if (u)
            {
              STMT_VCB(u)=LOCAL_VCB_ROOT;
              add_statement(u);
              emit_call(LOCAL_VCB_ROOT,STMT_UID(u),0);
              del_local_vcb=0;
            }
          else
            {
              yyval.node = TNULL;
              /* dummy operator */
            }
        }
      yyval.node=yyvsp[0].node;
    ;
    break;}
case 121:

{
      if(!yyvsp[0].node)
        yyval.node = TNULL;
      else
        {
          emit_call (TNULL, STMT_UID(CUR_DECL(yyvsp[0].node)), 2);
          yyval.node=FICTIVE_NODE;
          del_local_vcb=1;
        }
    ;
    break;}
case 122:

{
      dyn_sql_section_id = -2; /* !! */
      del_local_vcb=1;
      emit_call (TNULL,dyn_sql_section_id,2);
      yyval.node=FICTIVE_NODE;
    ;
    break;}
case 123:

{
      register TXTREF u=yyvsp[-1].node;
      u=gen_up_node(DELETE,u,yylsp[-3]);
      add_child(u,yyvsp[0].node);
      yyval.node=u;
    ;
    break;}
case 124:

{
      yyval.node = TNULL;
      if(yyvsp[0].node)
        {
          register TXTREF c,d;
          c = yyvsp[0].node;
          emit_call(LOCAL_VCB_ROOT,STMT_UID(CUR_DECL(c)),3);
          d = gen_up_node (DELETE, TNULL, yylsp[-1]);
          UPD_CURS(d) = c;
          STMT_VCB(d) = LOCAL_VCB_ROOT;
          LOCAL_VCB_ROOT = TNULL;
          add_statement(d);
          yyval.node = FICTIVE_NODE;
        }
      else
        {
          free_tree(yyvsp[0].node);
          FREE_VCB;
        }
    ;
    break;}
case 125:

{
      yyval.node = TNULL;
      if(yyvsp[0].node)
        {
          register TXTREF c,d;
          c = yyvsp[0].node;
          emit_call(LOCAL_VCB_ROOT,STMT_UID(CUR_DECL(c)),3);
          d = gen_up_node (DELETE, yyvsp[-1].node, yylsp[-3]);
          UPD_CURS(d) = c;
          STMT_VCB(d) = LOCAL_VCB_ROOT;
          LOCAL_VCB_ROOT = TNULL;
          add_statement(d);
          yyval.node = FICTIVE_NODE;
        }
      else
        {
          free_tree(yyvsp[-1].node);
          FREE_VCB;
        }
    ;
    break;}
case 126:

{
      yyval.node = TNULL;
      if(yyvsp[-2].node)
        {
          register TXTREF u;
          yyval.node=FICTIVE_NODE;
          u=gen_object(FETCH,yylsp[-3]);
          STMT_VCB(u)=LOCAL_VCB_ROOT;
          SetF_TRN(u,HAS_VCB_F);
          STMT_UID(u) = ARITY_TRN(CUR_DECL(yyvsp[-2].node));
          add_child(CUR_DECL(yyvsp[-2].node),u);
          emit_call(LOCAL_VCB_ROOT,STMT_UID(CUR_DECL(yyvsp[-2].node)),1);
          LOCAL_VCB_ROOT = TNULL;
        }
      free_line(yyvsp[0].node);
      if (yyval.node == TNULL)
        {
          FREE_VCB;
        }
    ;
    break;}
case 127:

{
       register TXTREF i;
       i=gen_object(INSERT,yylsp[-4]);
       add_child(i,yyvsp[-2].node);
       if(yyvsp[-1].node)
         {
           add_child(i,gen_parent(INTO,yyvsp[-1].node));
           SetF_TRN(i,COLUMNS_F);
         }
       add_child(i,yyvsp[0].node);
       if(CODE_TRN(yyvsp[0].node)==QUERY)SetF_TRN(i,QUERY_F);
       yyval.node=i;
     ;
    break;}
case 128:

{ yyval.node=gen_up_node(IVALUES,yyvsp[-1].node,yylsp[-3]); ;
    break;}
case 129:

{ yyval.node=yyvsp[0].node;;
    break;}
case 130:

{ yyval.node=yyvsp[0].node;;
    break;}
case 131:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 132:

{ yyval.node=yyvsp[0].node;  ;
    break;}
case 133:

{
     if(!yyvsp[0].node)
       yyval.node = TNULL;
     else
       {
         register TXTREF u=yyvsp[0].node,v;
         register TXTREF vcb=LOCAL_VCB_ROOT;
         u=STMT_VCB (DOWN_TRN (CUR_DECL(u)));
         LOCAL_VCB_ROOT=u;
         for(v=vcb;v;v=RIGHT_TRN(v))
           if(CODE_TRN(v)==PARAMETER)
             {
               u=find_info(PARAMETER,PAR_NAME(v));
               if(!u)
                 continue;
               if(PAR_STYPE(u).code==0)
                 PAR_STYPE(u)=PAR_STYPE(v);
               else if (PAR_STYPE(u).code!=PAR_STYPE(v).code)
                 yyerror("Error: Mismath operand types");
             }
         emit_call(LOCAL_VCB_ROOT,STMT_UID(CUR_DECL(yyvsp[0].node)),0);
         LOCAL_VCB_ROOT=vcb;
         yyval.node=FICTIVE_NODE;
         del_local_vcb=1;
       }
   ;
    break;}
case 134:

{
     yyval.node=FICTIVE_NODE;
     dyn_sql_section_id = -1; /* !! */
     emit_call (TNULL,dyn_sql_section_id,0);
     del_local_vcb=1;
    ;
    break;}
case 135:

{
      register TXTREF S=gen_object(SELECT,yylsp[-5]),s=yyvsp[-3].node,t;
      t=gen_up_node(INTO,yyvsp[-1].node,yylsp[-2]);
      MASK_TRN(S)  = MASK_TRN(yyvsp[0].node);
      DOWN_TRN(S)  = DOWN_TRN(yyvsp[0].node);
      ARITY_TRN(S) = ARITY_TRN(yyvsp[0].node);
      free_node(yyvsp[0].node);
      if(yyvsp[-4].code)SetF_TRN(S,DISTINCT_F);
      RIGHT_TRN(t)=RIGHT_TRN(DOWN_TRN(S));      /* insert after from */
      RIGHT_TRN(s)=t;
      RIGHT_TRN(DOWN_TRN(S))=s;
      ARITY_TRN(S)+=2;
      yyval.node=S;
    ;
    break;}
case 136:

{ yyval.code=0;;
    break;}
case 137:

{ yyval.code=1;;
    break;}
case 138:

{
      register TXTREF u=
       join_list(join_list(yyvsp[-3].node,gen_parent(ASSLIST,yyvsp[-1].node)),yyvsp[0].node);
      yyval.node=gen_up_node(UPDATE,u,yylsp[-4]);
    ;
    break;}
case 139:

{
      register TXTREF u = TNULL;
      if (yyvsp[0].node)
        {
          u=gen_up_node(UPDATE,join_list(yyvsp[-3].node,
                                         gen_parent(ASSLIST,yyvsp[-1].node)),yylsp[-4]);
          UPD_CURS(u)=yyvsp[0].node;
          SetF_TRN(yyvsp[0].node,CURS_UPD_F);
        }
      yyval.node=u;
    ;
    break;}
case 140:

{ yyval.node=yyvsp[0].node;;
    break;}
case 141:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 142:

{
      yyval.node=gen_up_node(ASSIGN,
                  join_list(gen_column(NULL,yyvsp[-2].ltrp,yylsp[-2]),yyvsp[0].node),
                           yylsp[-1]);
    ;
    break;}
case 143:

{ yyval.node=yyvsp[0].node;  ;
    break;}
case 144:

{ yyval.node=yyvsp[0].node;  ;
    break;}
case 145:

{ yyval.node=gen_object(NULL_VL,yylsp[0]);  ;
    break;}
case 146:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 147:

{
      register TXTREF n=yyvsp[-3].node;
      if ( (CODE_TRN(n)==UNION) && ((yyvsp[-1].code==0) || TstF_TRN(n,ALL_F) ))
        {
          add_child(n,yyvsp[0].node);
          if(yyvsp[-1].code==0)
            ClrF_TRN(n,ALL_F);
        }
      else
        {
          n=gen_up_node(UNION,join_list(yyvsp[-3].node,yyvsp[0].node),yylsp[-2]);
          if(yyvsp[-1].code > 0)
            SetF_TRN(n,ALL_F);
        }
      yyval.node=n;
    ;
    break;}
case 148:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 149:

{ yyval.node=yyvsp[-1].node; ;
    break;}
case 150:

{ yyval.node=yyvsp[-1].node; ;
    break;}
case 151:

{
      register TXTREF q=yyvsp[0].node,s=yyvsp[-1].node;
      set_location(q,yylsp[-3]);
      CODE_TRN(q)=QUERY;
      if(yyvsp[-2].code)SetF_TRN(q,DISTINCT_F);
      RIGHT_TRN(s)=RIGHT_TRN(DOWN_TRN(q));     /* insert after from */
      RIGHT_TRN(DOWN_TRN(q))=s;
      ARITY_TRN(q)++;
      yyval.node=q;
    ;
    break;}
case 152:

{
      yyval.node=gen_parent(SELECTION,yyvsp[0].node);
    ;
    break;}
case 153:

{
      yyval.node=gen_parent(SELECTION,gen_object(STAR,yylsp[0]));
    ;
    break;}
case 154:

{ yyval.node=yyvsp[0].node;;
    break;}
case 155:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 156:

{
      register TXTREF tbl;
      tbl=gen_parent(TBLEXP,join_list(
                              join_list(
                                join_list(yyvsp[-3].node,yyvsp[-2].node),
                                yyvsp[-1].node),
                              yyvsp[0].node));
      if(yyvsp[-2].node)SetF_TRN(tbl,WHERE_F);
      if(yyvsp[-1].node)SetF_TRN(tbl,GROUP_F);
      if(yyvsp[0].node)SetF_TRN(tbl,HAVING_F);
      if(subquery)SetF_TRN(tbl,SUBQUERY_F);
      subquery=0;
      yyval.node=tbl;
    ;
    break;}
case 157:

{
      yyval.node=gen_up_node(FROM,yyvsp[0].node,yylsp[-1]);
    ;
    break;}
case 158:

{ yyval.node=yyvsp[0].node;;
    break;}
case 159:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 160:

{
      yyval.node = gen_scanptr (yyvsp[-1].node, yyvsp[0].ltrp, yylsp[0]);
    ;
    break;}
case 161:

{
      yyval.node = gen_scanptr (yyvsp[0].node, (LTRLREF) NULL, tblnm.p);
    ;
    break;}
case 162:

{ yyval.node = TNULL;    ;
    break;}
case 163:

{ yyval.node = yyvsp[0].node;;
    break;}
case 164:

{
      yyval.node=gen_up_node(WHERE,yyvsp[0].node,yylsp[-1]);
    ;
    break;}
case 165:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 166:

{
      register TXTREF cursor=find_info(CURSOR,yyvsp[0].ltrp);
      if(!cursor)
        lperror("Cursor name '%s' not  found ",STRING(yyvsp[0].ltrp));
      yyval.node=cursor;
    ;
    break;}
case 167:

{ yyval.node = TNULL;    ;
    break;}
case 168:

{
      yyval.node = gen_up_node (GROUP, yyvsp[0].node, yylsp[-2]);
    ;
    break;}
case 169:

{ yyval.node = TNULL;    ;
    break;}
case 170:

{
      yyval.node = gen_up_node (HAVING, yyvsp[0].node, yylsp[-1]);
    ;
    break;}
case 171:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 172:

{ yyval.node=yyvsp[-1].node; ;
    break;}
case 173:

{ yyval.node=gen_oper(OR,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 174:

{ yyval.node=gen_oper(AND,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 175:

{
      TXTREF n=gen_node(NOT);
      set_location(n,yylsp[-1]);
      FUNC_OBJ(n)=yyvsp[0].node;
      ARITY_TRN(n)=1;
      yyval.node=n;
    ;
    break;}
case 176:

{
      yyval.node=TNULL;
      YYERROK;
      yyerror("error in condition");
    ;
    break;}
case 177:

{
      yyval.node=TNULL;
      YYERROK;
      yyerror("error in condition");
    ;
    break;}
case 178:

{
      yyval.node=TNULL;
      YYERROK;
      yyerror("error in condition");
    ;
    break;}
case 179:

{
      yyval.node=gen_up_node(EXISTS,yyvsp[0].node,yylsp[-1]);
    ;
    break;}
case 180:

{
      yyval.node=gen_up_node((yyvsp[-1].code?ISNOTNULL:ISNULL),
                           coltar_column(yyvsp[-3].node),yylsp[-2]);
    ;
    break;}
case 181:

{
      register TXTREF b;
      b=gen_up_node(BETWEEN,join_list(join_list(yyvsp[-5].node,yyvsp[-2].node),
                                      yyvsp[0].node),yylsp[-3]);
      if (yyvsp[-4].code)
        b=gen_parent(NOT,b);
      yyval.node=b;
    ;
    break;}
case 182:

{
      register TXTREF l;
      l=gen_up_node(LIKE,join_list(join_list(coltar_column(yyvsp[-4].node),
                                             yyvsp[-1].node),yyvsp[0].node),yylsp[-2]);
      if ( yyvsp[-3].code)
        l = gen_parent(NOT,l);
      yyval.node=l;
    ;
    break;}
case 183:

{
      register TXTREF i;
      i = gen_up_node(IN,join_list(yyvsp[-3].node,yyvsp[0].node),yylsp[-1]);
      if ( yyvsp[-2].code)
        i = gen_parent(NOT,i);
      yyval.node=i;
    ;
    break;}
case 184:

{
      TXTREF c = yyvsp[0].node;
      if (CODE_TRN(c) == NE)  /* quantified subquery */
        {
          CODE_TRN(c) = yyvsp[-1].code;
          DOWN_TRN(c) = join_list(yyvsp[-2].node,DOWN_TRN(c));
          ARITY_TRN(c) = 2;
          yyval.node = c;
        }
      else
        yyval.node=gen_up_node(yyvsp[-1].code,join_list(yyvsp[-2].node,c),yylsp[-1]);
    ;
    break;}
case 185:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 186:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 187:

{
      register TXTREF c = yyvsp[0].node;
      c=gen_parent(NE,c);
      SetF_TRN(c,QUANTIF_F);
      if(yyvsp[-1].code==2) SetF_TRN(c,SOME_F);
      yyval.node=c;
    ;
    break;}
case 188:

{ yyval.code=EQU; ;
    break;}
case 189:

{ yyval.code=NE;  ;
    break;}
case 190:

{ yyval.code=LT;  ;
    break;}
case 191:

{ yyval.code=GT;  ;
    break;}
case 192:

{ yyval.code=LE;  ;
    break;}
case 193:

{ yyval.code=GE;  ;
    break;}
case 194:

{ yyval.code=1; ;
    break;}
case 195:

{ yyval.code=2; ;
    break;}
case 196:

{ yyval.code=2; ;
    break;}
case 197:

{ yyval.code=0; ;
    break;}
case 198:

{ yyval.code=1; ;
    break;}
case 199:

{ yyval.node = TNULL; ;
    break;}
case 200:

{ yyval.node = yyvsp[0].node; ;
    break;}
case 201:

{ yyval.node=yyvsp[0].node;;
    break;}
case 202:

{ yyval.node=gen_parent(VALUES,yyvsp[-1].node); ;
    break;}
case 203:

{
      yyval.node=TNULL;
      YYERROK;
      yyerror("error in IN predicate list" );
    ;
    break;}
case 204:

{ yyval.node=yyvsp[0].node;;
    break;}
case 205:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node);;
    break;}
case 206:

{
      register TXTREF sq=yyvsp[-1].node,s=yyvsp[-2].node;
      set_location(sq,yylsp[-5]);
      CODE_TRN(sq)=SUBQUERY;
      if(yyvsp[-3].code)SetF_TRN(sq,DISTINCT_F);
      RIGHT_TRN(s)=RIGHT_TRN(DOWN_TRN(sq));     /* insert after from */
      RIGHT_TRN(DOWN_TRN(sq))=s;
      ARITY_TRN(sq)++;
      subquery=1;
      yyval.node=sq;
    ;
    break;}
case 207:

{ 
     yyerror("Error in subquery: skipped to \')\'");
     yyval.node = TNULL; 
   ;
    break;}
case 208:

{
      yyval.node=gen_parent(RESULT,yyvsp[0].node);
    ;
    break;}
case 209:

{
      yyval.node=gen_parent(RESULT,gen_object(STAR,yylsp[0]));
    ;
    break;}
case 210:

{ yyval.code=0; ;
    break;}
case 211:

{ yyval.code=1; ;
    break;}
case 212:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 213:

{ yyval.node=yyvsp[-1].node; ;
    break;}
case 214:

{ yyval.node=gen_oper(ADD,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 215:

{ yyval.node=gen_oper(SUB,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 216:

{ yyval.node=gen_oper(MULT,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 217:

{ yyval.node=gen_oper(DIV,yyvsp[-2].node,yyvsp[0].node,yylsp[-1]); ;
    break;}
case 218:

{
      TXTREF n=yyvsp[-1].node;
      if(!n)
        yyval.node=yyvsp[0].node;
      else
        if(CODE_TRN(yyvsp[0].node)==UMINUS)
          {
            yyval.node=FUNC_OBJ(yyvsp[0].node);
            free_node(yyvsp[0].node);     /* double minus elimination */
            free_node(yyvsp[-1].node);
          }
        else
          {
            FUNC_OBJ(n)=yyvsp[0].node;
            ARITY_TRN(n)=1;
            yyval.node=n;
          }
    ;
    break;}
case 219:

{   yyval.node = TNULL;           ;
    break;}
case 220:

{   yyval.node = gen_object (UMINUS, yylsp[0]); ;
    break;}
case 221:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 222:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 223:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 224:

{  yyval.node=gen_object(USERNAME,yylsp[0]); ;
    break;}
case 225:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 226:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 227:

{
      TXTREF n = yyvsp[-1].node;
      if ( ! n )
        yyval.node = yyvsp[0].node;
      else
        {
          char *s;
          i4_t  l;
          free_node (n);
          yyval.node = n = yyvsp[0].node;
          l = strlen (STRING (CNST_NAME (n))) + 2;
          s = xmalloc (l);
          strcpy (s, "-");
          strcat (s, STRING(CNST_NAME(n)));
          CNST_NAME (n) = ltr_rec (s);
          xfree (s);
        }
    ;
    break;}
case 228:

{  yyval.node = gen_object(USERNAME,yylsp[0]); ;
    break;}
case 229:

{
      yyval.node=gen_func(COUNT,yylsp[-3], TNULL,0);
    ;
    break;}
case 230:

{
      yyval.node=gen_func(COUNT,yylsp[-4],yyvsp[-1].node,1);
    ;
    break;}
case 231:

{
      yyval.node=gen_func(yyvsp[-4].code,yylsp[-4],yyvsp[-1].node,1);
    ;
    break;}
case 232:

{
      yyval.node=gen_func(yyvsp[-4].code,yylsp[-4],yyvsp[-1].node,0);
    ;
    break;}
case 233:

{ yyval.code=AVG; ;
    break;}
case 234:

{ yyval.code=MAX; ;
    break;}
case 235:

{ yyval.code=MIN; ;
    break;}
case 236:

{ yyval.code=SUM; ;
    break;}
case 237:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 238:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 239:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 240:

{ yyval.node=yyvsp[0].node; ;
    break;}
case 241:

{ yyval.type=pack_type(SQLType_Char,1,0);                        ;
    break;}
case 242:

{ yyval.type=pack_type(SQLType_Short,5,0);                       ;
    break;}
case 243:

{ yyval.type=pack_type(SQLType_Int,10,0);                        ;
    break;}
case 244:

{ yyval.type=pack_type(SQLType_Real,0,0);                        ;
    break;}
case 245:

{ yyval.type=pack_type(SQLType_Double,0,0);                      ;
    break;}
case 246:

{ yyval.type=pack_type(SQLType_Double,0,0);                      ;
    break;}
case 247:

{ yyval.type=pack_type(SQLType_Float,atol(STRING(CNST_NAME(yyvsp[-1].node))),0);  ;
    break;}
case 248:

{ yyval.type=pack_type(SQLType_Real,0,0);  ;
    break;}
case 249:

{ yyval.type=pack_type(SQLType_Char,atol(STRING(CNST_NAME(yyvsp[-1].node))),0);   ;
    break;}
case 250:

{ yyval.type=pack_type(SQLType_Int,0,0);    ;
    break;}
case 251:

{ yyval.type=pack_type(SQLType_Num,atol(STRING(CNST_NAME(yyvsp[-1].node))),0);    ;
    break;}
case 252:

{ yyval.type=pack_type(SQLType_Num,atol(STRING(CNST_NAME(yyvsp[-3].node))),
                           atol(STRING(CNST_NAME(yyvsp[-1].node))));
     ;
    break;}
case 253:

{
       TXTREF n;
       if(!tblnm.a)
         tblnm.a=GL_AUTHOR;
       n = find_table (ANY_TBL, tblnm.a, tblnm.n);
       if (n)
         {
           yyerror ("Error: Duplicate table name definition\n");
           yyval.node = TNULL;
         }
       else
         {
           n = gen_node (ANY_TBL);
           /* SetF_TRN(n,CHECKED_F); */
           /* table hasn't  not already defined yet */
           TBL_FNAME (n) = tblnm.a;
           TBL_NAME (n) = tblnm.n;
           add_info (n);
           yyval.node = new_table = n;
	   new_table_col_no = 0;
         }
     ;
    break;}
case 254:

{
       TXTREF n;
       if (!tblnm.a)
         tblnm.a=GL_AUTHOR;
       n = find_table (ANY_TBL, tblnm.a, tblnm.n);
       if (!n)
         {
           n = gen_node (ANY_TBL);
           TBL_FNAME (n) = tblnm.a;
           TBL_NAME (n) = tblnm.n;
           add_info (n);
         }
       yyval.node = n;
     ;
    break;}
case 255:

{
       yyval.node = gen_scanptr (yyvsp[0].node, (LTRLREF) NULL, tblnm.p);
     ;
    break;}
case 256:

{ /*  user_identifier.tablename  or correlation name */
      tblnm.a  = (LTRLREF) NULL;
      tblnm.n  = yyvsp[0].ltrp;
      tblnm.p  = yylsp[0];
      yyval.code = 0;
    ;
    break;}
case 257:

{ /* authorization.tablename */
      tblnm.a  = yyvsp[-2].ltrp;
      tblnm.n  = yyvsp[0].ltrp;
      tblnm.p  = yylsp[-2];
      yyval.code = 0;
    ;
    break;}
case 258:

{ yyval.node = yyvsp[0].node;                     ;
    break;}
case 259:

{ yyval.node = join_list(yyvsp[-2].node,yyvsp[0].node); ;
    break;}
case 260:

{  yyval.node=gen_column(NULL,yyvsp[0].ltrp,yylsp[0]);  ;
    break;}
case 261:

{ /*  user_identifier.tablename  or correlation name */
      tblnm.a  = (LTRLREF) NULL;
      tblnm.n  = yyvsp[-2].ltrp;
      tblnm.p  = yylsp[-2];
      yyval.node = gen_column (&tblnm, yyvsp[0].ltrp, yylsp[0]);
    ;
    break;}
case 262:

{ /* authorization.tablename */
      tblnm.a  = yyvsp[-4].ltrp;
      tblnm.n  = yyvsp[-2].ltrp;
      tblnm.p  = yylsp[-4];
      yyval.node = gen_column (&tblnm, yyvsp[0].ltrp, yylsp[0]);
    ;
    break;}
case 263:

{ yyval.node=yyvsp[0].node;                     ;
    break;}
case 264:

{ yyval.node=join_list(yyvsp[-2].node,yyvsp[0].node); ;
    break;}
case 265:

{
      register TXTREF t=OBJ_DESC(yyvsp[0].node);
      SetF_TRN(t,OUT_F);
	  if( !TstF_TRN(t,INDICATOR_F) && PAR_INDICATOR(t) != TNULL )
	    SetF_TRN(PAR_INDICATOR(t),OUT_F);
      yyval.node=yyvsp[0].node;
    ;
    break;}
case 266:

{  yyval.node=get_parm_node(yyvsp[0].ltrp,yylsp[0],1);  ;
    break;}
case 267:

{  yyval.node=get_parm_node(yyvsp[0].ltrp,yylsp[0],0);  ;
    break;}
case 268:

{
      yyval.node=get_ind(get_param(yyvsp[-2].ltrp,1,yylsp[-2]),get_param(yyvsp[0].ltrp,1,yylsp[0]),yylsp[-1]);
    ;
    break;}
case 269:

{
      yyval.node=get_ind(get_param(yyvsp[-1].ltrp,1,yylsp[-1]),get_param(yyvsp[0].ltrp,1,yylsp[0]),yylsp[0]);
    ;
    break;}
case 270:

{
      yyval.node=get_ind(get_param(yyvsp[-2].ltrp,0,yylsp[-2]),get_param(yyvsp[0].ltrp,0,yylsp[0]),yylsp[-1]);
    ;
    break;}
case 271:

{
      yyval.node=get_ind(get_param(yyvsp[-1].ltrp,0,yylsp[-1]),get_param(yyvsp[0].ltrp,0,yylsp[0]),yylsp[0]);
    ;
    break;}
case 272:

{
       TXTREF n;
       n=find_info(PARAMETER,yyvsp[0].ltrp);
       if(n)
         yyval.node=get_parm_node(yyvsp[0].ltrp,yylsp[0],1);
       else
         yyval.node=gen_column(NULL,yyvsp[0].ltrp,yylsp[0]);
     ;
    break;}
case 273:

{ /*  user_identifier.tablename  or correlation name */
      tblnm.a  = (LTRLREF) NULL;
      tblnm.n  = yyvsp[-2].ltrp;
      tblnm.p  = yylsp[-2];
      yyval.node = gen_column (&tblnm, yyvsp[0].ltrp, yylsp[0]);
    ;
    break;}
case 274:

{ /* authorization.tablename */
      tblnm.a  = yyvsp[-4].ltrp;
      tblnm.n  = yyvsp[-2].ltrp;
      tblnm.p  = yylsp[-4];
      yyval.node = gen_column (&tblnm, yyvsp[0].ltrp, yylsp[0]);
    ;
    break;}
case 275:

{ yyval.node=get_parm_node(yyvsp[0].ltrp,yylsp[0],0);     ;
    break;}
case 276:

{
       yyval.node=get_ind(get_param(yyvsp[-2].ltrp,1,yylsp[-2]),get_param(yyvsp[0].ltrp,1,yylsp[0]),yylsp[-1]);
     ;
    break;}
case 277:

{
       yyval.node=get_ind(get_param(yyvsp[-1].ltrp,1,yylsp[-1]),get_param(yyvsp[0].ltrp,1,yylsp[0]),yylsp[0]);
     ;
    break;}
case 278:

{
       yyval.node=get_ind(get_param(yyvsp[-2].ltrp,0,yylsp[-2]),get_param(yyvsp[0].ltrp,0,yylsp[0]),yylsp[-1]);
     ;
    break;}
case 279:

{
       yyval.node=get_ind(get_param(yyvsp[-1].ltrp,0,yylsp[-1]),get_param(yyvsp[0].ltrp,0,yylsp[0]),yylsp[0]);
     ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */


  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}



static void
free_tail(void)
{
  if (del_local_vcb)
    FREE_VCB;
  LOCAL_VCB_ROOT = TNULL;
  del_local_vcb = 0;
}


static TXTREF holes_tbl = TNULL;

static TXTREF 
replace_clm_hole(TXTREF clmptr,i4_t f)
{
  register TXTREF ptr,clm;
  register enum token code=CODE_TRN(clmptr);
  assert(f==CYCLER_LD);
  if(code!=COLPTR)return clmptr;
  ptr=OBJ_DESC(clmptr);
  if(CODE_TRN(ptr)!=COLUMN_HOLE)return clmptr;
  clm=find_column(holes_tbl,CHOLE_CNAME(ptr));
  if(!clm)
    {
      if (TstF_TRN(holes_tbl,CHECKED_F))
        lperror("Incorrect column name '%s' used",STRING(CHOLE_CNAME(ptr)));
      else
        {
          add_column(holes_tbl,CHOLE_CNAME(ptr));
          clm=find_column(holes_tbl,CHOLE_CNAME(ptr));
        }
    }
  free_node(ptr);
  OBJ_DESC(clmptr)=clm;
  return clmptr;
}

static TXTREF 
replace_column_holes(TXTREF rb,VCBREF tbl)
{
  holes_tbl = tbl;
  rb=cycler(rb,replace_clm_hole,CYCLER_LD+CYCLER_LN);
  holes_tbl = TNULL;
  return rb;
}

static void 
add_table_column(enum token tbl_code,LTRLREF ltrp,sql_type_t type,TXTREF def,TXTREF constr)
{
  register TXTREF col;
  register i4_t    can_be_null = 1;
  
  if(!new_table) return;
  if(CODE_TRN(new_table)==ANY_TBL)
    CODE_TRN(new_table)=tbl_code;
  TASSERT(tbl_code == CODE_TRN(new_table),new_table);
  col = find_column(new_table,ltrp);
  if (col)
    {
      lperror("Duplicate column '%s' definition in table '%s.%s'",STRING(ltrp),
              STRING(TBL_FNAME(new_table)),STRING(TBL_NAME(new_table)));
      if(def)
        free_tree(def);
      if(constr)
        free_tree(constr);
    }
  else
    {
      add_column(new_table,ltrp);
      col=find_column(new_table,ltrp);
      COL_TYPE(col)   = type;
      COL_DEFAULT(col)= def;
      COL_NO(col) = new_table_col_no++;
    }

  while(constr)
    {
      register TXTREF c = constr;
      i4_t             null_vl = 0;
      constr = RIGHT_TRN(c);
      RIGHT_TRN(c) = TNULL;
      switch(CODE_TRN(c))
	{
	case NULL_VL:
          free_node(c);
          null_vl=1;
	case PRIMARY:
	case UNIQUE:
	  can_be_null = 0;
#define P_(code,subtree) gen_parent(code,subtree)
          TBL_CONSTR(new_table) = 
	    join_list(P_(CHECK,P_(ISNOTNULL,gen_colptr(col))),
		      TBL_CONSTR(new_table));
#undef P_
          if(null_vl)
            break;
	case INDEX:
	  ARITY_TRN(c) = 1;
	  DOWN_TRN(c)  = gen_colptr(col);
	  IND_INFO(new_table)=join_list(c,IND_INFO(new_table));
	  break;
	case CHECK:
	  TBL_CONSTR(new_table) = 
	    join_list (replace_column_holes(c,new_table),
		       TBL_CONSTR(new_table));
	  break;
	case REFERENCE:
          TBL_CONSTR(new_table)=
            join_list(gen_parent(FOREIGN,
                                 join_list(gen_parent(LOCALLIST,gen_colptr(col)),c)),
                      TBL_CONSTR(new_table));
          break;
	default:
	  debug_trn(c);
	  yyfatal("Unexpected column constraints found");
	  break;
	}
    }
  
  if (!def && can_be_null)
    COL_DEFAULT (col) = gen_node (NULL_VL);
  
  if(COL_DEFAULT(col) && CODE_TRN(COL_DEFAULT(col))==NULL_VL)
    {
      if (can_be_null)
        NULL_TYPE(COL_DEFAULT (col)) = COL_TYPE(col);
      else
        yyerror("Error: ambiguous column description");
    }
#if 0
  {
    MASKTYPE x = MASK_TRN(new_table);
    debug_trn(new_table);
    MASK_TRN(new_table) = x;
  }
#endif
}

/*
 * 'check_not_null' check columns in UNIQUE or PRIMARY key definition
 * for constraints 'not null'.
 */

static void
check_not_null(TXTREF ind)
{
  TXTREF tbl = COL_TBL(OBJ_DESC(DOWN_TRN(ind)));
  TXTREF constr,cp;
  for ( cp = DOWN_TRN(ind);cp;cp = RIGHT_TRN(cp)) /* check every column */
    {
      TXTREF col = OBJ_DESC(cp);
      for(constr = TBL_CONSTR(tbl);constr;constr = RIGHT_TRN(constr))
        {
          /*
           * if ( constr = (Check (IsNotNull (ColPtr <col>))))
           */
          TXTREF pred = DOWN_TRN(constr);
          if(CODE_TRN(pred) == NOT)
            {
              pred = DOWN_TRN(pred);
              switch(CODE_TRN(pred))
                {
                case ISNULL:
                  CODE_TRN(pred)  = ISNOTNULL;
                  free_node(DOWN_TRN(constr));
                  DOWN_TRN(constr) = pred;
                  break;
                default: break; 
                }
            }
          if(CODE_TRN(pred) != ISNOTNULL)
            continue;
          pred = DOWN_TRN(pred);
          if(CODE_TRN(pred) != COLPTR) /* it quite strange */
            continue;
          if(OBJ_DESC(pred) == col) /* if there is a constraint on given column */
            break;
        }
      if (constr) /* something was found */
        continue;
      /* if we have not found 'not null' constraints on given column */
      file_pos = LOCATION_TRN(cp);
      lperror("Warning: primary key column '%s.%s.%s' not restricted\n"
              "\t\tby 'not null' qualifier",
              STRING(TBL_FNAME(tbl)),STRING(TBL_NAME(tbl)),
              STRING(COL_NAME(col)));
      errors--; /* clear error flag - translate message as a warning */
      if (CODE_TRN(COL_DEFAULT(col))==NULL_VL)
        {
          free_node(COL_DEFAULT(col));
          COL_DEFAULT(col) = TNULL;
        }
      col = gen_node(COLPTR);
      OBJ_DESC(col) = OBJ_DESC(cp);
      TBL_CONSTR(tbl) = 
        join_list (gen_parent(CHECK,gen_parent(ISNOTNULL,col)),
                   TBL_CONSTR(new_table));
    }
}

static void
emit_module_proc(VCBREF parmlist,LTRLREF procname)
{
  if (call.subst==NULL)
    call.subst = (call_subst_t*)xmalloc (sizeof(call_subst_t));
  call.subst->proc_name = savestring(STRING(procname));
  describe_stmt(&(call.subst->interface),parmlist,'I');
  free_tail();
}

static void
emit_call(TXTREF vcb,i4_t object_id, i4_t method_id)
{
  if (call.subst==NULL)
    call.subst = (call_subst_t*)xmalloc ( sizeof(call_subst_t));
  call.subst->object = object_id;
  call.subst->method = method_id;
  describe_stmt(&(call.subst->in_sql_parm),vcb,'>');
  describe_stmt(&(call.subst->out_sql_parm),vcb,'<');
  call.subst->jmp_on_eofscan = savestring(label_nf?label_nf:"");
  call.subst->jmp_on_error   = savestring(label_er?label_er:"");
}

call_t *
prepare_replacement(void)
{
  call_t *c;
  c = (call_t*)xmalloc ( sizeof(call_t));
  c->subst = call.subst;
  if(c->subst)  /* preserve NULL string reference */
    {
      if (!call.subst->proc_name)
        call.subst->proc_name      =  savestring("");
      if (!call.subst->jmp_on_eofscan)
        call.subst->jmp_on_eofscan =  savestring("");
      if (!call.subst->jmp_on_error)
        call.subst->jmp_on_error   =  savestring("");
    }
  return c;
}

i4_t 
sql_parse(void)
{
  i4_t rc;
  yydebug=parse_debug;
  parse_mode=Esql;
  dyn_sql_section_id = 0;
  bzero(&call,sizeof(call));
  rc = yyparse();
  dyn_sql_stmt_name = NULL;
  return rc;
}
